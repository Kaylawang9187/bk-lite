# 行为准则与工作流

你要做什么
	•	在给出代码前，你需要先了解仓库的周边信息，包括：requirements/、src/ 目录, .env.example 等
	•	不臆测：当需求/约束缺失时，先在仓库内搜索（同名模块、接口、常量、配置），复用已有模式；若仍缺失，提供 A/B 两种可选实现（优先选择变更面更小的方案）。
	•	就地最小改动：能复用就不重写；能扩展就不分叉；能配置就不硬编码。
	•	输出可运行的最小增量

你不要做什么
	•	不写“炫技”或“过度抽象”的代码；不制造无意义的小函数拆分。
	•	不在日志中打印敏感信息（密钥、密码、Token、个人数据）。

交付格式优先级
	1.	补丁式变更（建议）：给出目录、文件与关键段落的修改点，或最小可复制粘贴的代码块。
	2.	伴随说明：变更动机、边界条件、替代方案与影响范围。

# 思考与决策模式
	1.	澄清目标：功能做什么 → 对外契约（输入/输出/错误） → 成功/失败判据。
	2.	境内复用：现有模块/类型/错误模型/日志规范/配置方式是否可用？
	3.	约束校验：依赖白名单、异步模型（Sanic）、性能预算、异常策略、安全合规。
	4.	方案权衡：给出 1–2 种实现；说明取舍（复杂度、可维护性、扩展性、性能）。
	5.	落地路径：最小可行集合（代码/配置/迁移/测试/文档）；如何灰度/回滚。
	6.	验收与观测：日志字段、指标、告警门槛、手动验证步骤。

输出前自检清单：可运行？类型/格式通过？日志可读？错误一致？


# 编码规范（Python）
	•	遵循 PEP 8；尽量使用 类型注解（对外接口、复杂逻辑必须补齐）。
	•	Docstring 采用 Google 风格或与项目现有风格一致（保持一致最重要）。
	•	函数以单一职责为原则；必要时用内联注释解释 “为什么”（非“做什么”）。
	•	命名清晰：避免拼音与含糊缩写；模块/包名小写下划线。
	•	侧重 可读性 > 微优化。优先早返回、少分支、可组合的小型块。

# 日志与可观测性
	•	使用：from sanic.log import logger
	•	关键节点要有日志：入口、外部调用前后、分支选择、重试、异常捕获、状态变更。
	•	结构化内容。
	•	禁止打印敏感信息；必要参数要打概要（如哈希或掩码）。

# 依赖与配置
	•	仅允许使用 requirements/ 中列出的库；新增依赖需在 PR 描述中说明用途与必要性。
	•	配置使用 环境变量 或集中配置模块；提供 env.example；不把默认密钥写进仓库。
	•	优先标准库与已存在的第三方库功能，不重复造轮子。

# 错误处理与返回约定
	•	绝不吞异常：顶层捕获时要记录上下文（参数概要、下游标识、耗时）。

# Sanic 专项规范
	•	异步正确性：
	•	外部 I/O 使用 async 客户端（HTTP/DB/缓存等）。
	•	谨慎使用 asyncio.gather，必要时加 并发上限（Semaphore）。
	•	为每次调用设置 超时 与 取消 处理；避免阻塞调用。
	•	请求校验：入口用 Pydantic 模型或现有校验工具，拒绝脏数据进入核心逻辑。
	•	响应：使用 sanic.response.json(...)；设置 content_type、charset 与缓存头按需。
	•	中间件：统一注入 request_id、审计字段、鉴权信息；必要时做 CORS、限流、速率控制。

# 性能与并发
	•	所有外部调用设置 超时；为重试定义 退避策略（如指数退避，次数受限）。
	•	使用连接池/会话复用；避免热路径上的重复序列化/反序列化。
	•	对 CPU 密集型任务，使用任务队列或后台进程，不要阻塞事件循环。

# 安全基线
	•	输入校验 + 输出编码；避免注入与路径遍历。
	•	Secrets 通过环境变量/密钥管理；日志/错误不泄漏内部信息。
	•	若涉及鉴权：统一中间件处理；令牌校验、最小权限、过期与刷新策略清晰。
	•	跨域/CORS、速率限制、防重放（必要时）、下载与上传白名单。

总目标：让每一次改动都“可读、可测、可回滚、可观测”。当你不确定时，优先选择小步快跑 + 明确边界的实现